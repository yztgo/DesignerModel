# redis核心
redis和客户端通过网络交互指令和信息，要求客户端要求redis按照指令对传递的数据信息进行操作，但是单线程是串行化执行指令和信息的，原子性问题；
## redis消息队列 作为一个中心化的消息转发器
PubSub发布订阅模型：channel通道
消息队列redis作为一个中间件，直接向外推送消息，不管有没有订阅该channel的消费者（正则匹配），他都会向外推送而不保存消息，就会出现消息丢失，消费者内存溢出等等问题，并且不支持持久化。
但是它支持多生产多消费。并且消费者Listener是阻塞式监听，没有消息的时候不会占用CPU资源。
注意：redis中设置存储对象的过期时间EXPIRE就是通过PubSub进行redis向生产者进行通知的 ，这也是使用redis中的过期校验实现延时任务的一个缺点，

多生产者多消费者的大量连接：redis单线程的IO多路复用的作用；

如何实现极致的低耗能：
建立JedisPoll连接池：将已经连接好的TCP连接通道放在连接池中（客户端），单个生产者中的多个用户的请求（多线程）发送消息，单个消费者中的多个线程接收消息，但是生产者消费者中封装/处理消息的事务“并发”锁等消耗是我们开发者自己需要解决的。


## redis消息队列 Stream : 消息是永久存在的 消费者拉
XADD "队列名" *（作为该消息的唯一标识） "键值对形式消息数组”  
XREAD COUNT "往后读取的数量" BLOCK "阻塞时间" STREAM “队列名" "起始读取的位置（$表示最新的数据，是指执行该命令之后队列中生产的新数据，但是可能会出现漏读消息的问题)"  
XGROUP CREATE 队列名称 生产者组名 队列中的起始ID  ： 将队列放到这个生产者组中并标记读取该组中的该队列的时候是从哪一个位置开始读取   
XREADGROUP GROUP 消费组名称 消费者名 COUNT 消费数量 BLOCK 阻塞时间 NOACK STEAMS 队列名称 >(这个大于号表示读取队列中未被消费的数据）  


## 基于ZSet实现延时任务
通过LUA脚本实现提取任务和删除任务的原子性（相当于sychonized(方法） mysql中的事务）操作 避免多线程的重复操作 通过@Schedule实现轮询
