# redis核心
## redis消息队列 作为一个中心化的消息转发器
PubSub发布订阅模型：channel通道
消息队列redis作为一个中间件，直接向外推送消息，不管有没有订阅该channel的消费者（正则匹配），他都会向外推送而不保存消息，就会出现消息丢失，消费者内存溢出等等问题，并且不支持持久化。
但是它支持多生产多消费。

多生产者多消费者的大量连接：redis单线程的IO多路复用的作用；

如何实现极致的低耗能：
建立JedisPoll连接池：将已经连接好的TCP连接通道放在连接池中（客户端），单个生产者中的多个用户的请求（多线程）发送消息，单个消费者中的多个线程接收消息，但是生产者消费者中封装/处理消息的事务“并发”锁等消耗是我们开发者自己需要解决的。


## redis消息队列 Stream : 消息是永久存在的 消费者拉
XADD "队列名" *（作为该消息的唯一标识） "键值对形式消息数组”  
XREAD COUNT "往后读取的数量" BLOCK "阻塞时间" STREAM “队列名" "起始读取的位置（$表示最新的数据，是指执行该命令之后队列中生产的新数据，但是可能会出现漏读消息的问题)"
XGROUP CREATE 队列名称 生产者组名 队列中的起始ID  ： 将队列放到这个生产者组中并标记读取该组中的该队列的时候是从哪一个位置开始读取 
XREADGROUP GROUP 消费组名称 消费者名 COUNT 消费数量 BLOCK 阻塞时间 NOACK STEAMS 队列名称 >(这个大于号表示读取队列中未被消费的数据）
